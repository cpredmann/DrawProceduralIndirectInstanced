// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel IndexKernel 

RWStructuredBuffer<uint> indices;
RWStructuredBuffer<float3> points;

int loops;
int sides;

#define PI 3.14159

[numthreads(1,1,1)]
void IndexKernel (uint3 id : SV_DispatchThreadID)
{
  uint loop = id.x;
  uint side = id.y;
  int s = side + sides + 1;

  int hs = s - sides;
  int offset = sides * (loop - 1);
  int p0 = s + offset;
  int p1 = p0 + 1;
  int p3 = hs + offset;
  int p2 = p3 + 1;
  if (p1 > (sides * (loop + 1)))
  {
    p1 = (s - sides) + offset + 1;
  }
  if (p2 > (sides * loop))
  {
    p2 = (hs - sides) + offset + 1;
  }
  uint c = loop * sides + side;

  if (loop == 0) {
      c *= 3;
      indices[c] = 0;
      indices[c + 1] = p0;
      indices[c + 2] = p1;
  } else {
      c *= 6;
      c -= 3 * sides;
      indices[c] = p0;
      indices[c + 1] = p1;
      indices[c + 2] = p2;
      indices[c + 3] = p2;
      indices[c + 4] = p3;
      indices[c + 5] = p0;
  }
}


#pragma kernel PointsKernel

[numthreads(1,1,1)]
void PointsKernel (uint3 id : SV_DispatchThreadID)
{
  uint loop = id.x;
  uint side = id.y;
  
  float a = PI * 2.0f / sides;
  float r = 1.0f / loops;

  if (loop == 0 && side == 0) {
    points[0] = float3(0.0f, 0.0f, 0.0f);
  }

  float lrad = r * (loop + 1);

  int c = loop * sides + side + 1;
  

  points[c] = float3(cos(side * a) * lrad, sin(side * a) * lrad, 0.0f);
  
}